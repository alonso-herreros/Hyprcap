#!/usr/bin/env sh

readonly VERSION="None (not yet released)"

readonly CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/hyprcap"
readonly CAPTURE_FILENAME="capture"
readonly CAPTURE_PATH="$CACHE_DIR/$CAPTURE_FILENAME"

readonly DMENU_COMMAND="fuzzel -d"

readonly SLURP_BORDER_WEIGHT=1

# readonly DUNST_TAG="hyprcap" # Only for dunst
readonly NOTIF_ID="1978388086" # Random ID generated by `qalc 'rand(2^31-1)'`


# =============== Help, Version, logging ===============

function Help() {
    cat <<EOF
Usage: hyprcap [options...] <command> [[-s] <selection>]

HyprCap is a utility to easily capture screenshots and screen recordings on
Hyprland.

NOTE: HyprCap is still in early development. Options marked with an exclamation
mark (!) are not implemented but are planned.

Please report bugs and issues at
https://github.com/alonso-herreros/hyprcap/issues

Commands:
! shot | screenshot        Take a screenshot (default)
! rec | record             Take a screen recording

A selection can be specified after the command, with the -m or --mode option,
or using a dmenu-like menu if neither is specified.

Selection:
! monitor                   Select an entire monitor interactively.
! monitor:active            Select the currently focused monitor.
! monitor:<name>            Select the monitor with the exact given name

! window                    Select a visible window interactively.
! window:active             Select the currently focused window.
! window:<title>            Select the first window that contains the title.

  region                    Select a region manually using 'slurp'.
  region:X,Y,WxH            Select the specified region.


Selection options:
  -s, --select <selection>      Alternative way to specify the selection.

Saving options:
! -o, --output-dir <dir>        Directory in which to save captures.
                                Default: \$XDG_PICTURES_DIR/Screenshots or
                                \$XDG_VIDEOS_DIR/Captures
! -f, --filename <filename>     The file name for the resulting capture within
                                the output directory.
                                Default:
                                  YYYY-MM-DD-hhmmss_hyprcap.<extension>
                                where <extension> is determined by the command
                                (e.g. png for screenshots, mpeg for recordings).
  -F, --no-file                 Don't save captures to a file (default).
! -c, --copy                    Copy capture to clipboard with 'wl-copy'.

Capture options:
! -d, --delay <time>            How long to delay starting the capture after
                                selection is done in seconds.
! -z, --freeze                  Freeze the screen on initialization. Only
                                available for screenshots.

Notification options:
! -n, --notify                  Send a notification when capture is done.
  -N, --no-notify               Never send a notification (default).
! -a, --actions                 Show actions in the notification (default).
                                Requires --notify.
  -A, --no-actions              Don't show actions in the notification. Requires
                                --notify.
! -t, --notif-timeout <time>    Notification timeout in milliseconds. Requires
                                --notify
                                Default: 10 seconds.

Output options:
! -r, --raw                     Output raw capture data to stdout.
  -v, --verbose                 Print extra information. Specify multiple times
                                to increase verbosity.
  -q, --quiet                   Print less information.
  -V, --version                 Show the version and exit.
  -h, --help                    Show this help message and exit.

Examples:
  Record current monitor                \`hyprcap rec monitor:active\`
  Screenshot a window (interactive)     \`hyprcap shot window\`
  Record a specific region              \`hyprcap -m output -m DP-1\`
EOF
}

function Version() {
    echo "HyprCap version $VERSION"
}

function NYI() {
    Print -E "Fatal: You have requested a feature that is not yet implemented\n"
}

# TODO: Check this implementation
function Print() {
    # Sort of like an if with a string pattern match
    case "$1" in -*)
        local level=${1#-}
        shift;;
    esac
    [ "$level" == "E" ] && level=-1 # Error level
    [ $VERBOSE -ge ${level:-0} ] && printf "$@" 1>&2
}


# =============== Main operations ===============

# --------------- Capture functions ---------------

# function capture() {
#     local geometry="${1}"

#     if [ $RAW -eq 1 ]; then
#         grim -g "${geometry}" -
#         return 0
#     fi

#     mkdir -p "$CACHEDIR"
#     grim -g "${geometry}" "$CAPTURE_FULLPATH"

#     [ $CLIPBOARD -eq 1 ] && copy_capture >/dev/null
#     [ $SAVE -eq 1 ] && save_capture >/dev/null

#     notify $output
# }

# --------------- Geometry grabbing ---------------

# function list_geometry () {
#     # [ "$1" = with_title ] && local append="\t\(.title)"
#     # [ "$1" = only_title ] && local append="\t\(.title)" || local info=""
#     hyprctl -j clients | jq -r '.[] | select(.workspace.id | contains('$(hyprctl -j monitors | jq -r 'map(.activeWorkspace.id) | join(",")')'))'
# }

function get_geometry() {
    local geometry=

    case $SELECTION in
        region)
            geometry=$(grab_region)
            geometry=$(trim_slurp_border "$geometry")
            ;;
        monitor)
            if [ $SELECT_ACTIVE -eq 1 ]; then
                geometry=$(grab_monitor_active)
            elif [ -n "$SELECT_MATCH" ]; then
                geometry=$(grab_monitor_match $SELECT_MATCH)
            else
                geometry=$(grab_monitor)
            fi
            ;;
        window)
            NYI && exit 1;; # TODO: Remove when implemented
#             if [ $CURRENT -eq 1 ]; then
#                 local geometry=$(grab_active_window)
#             elif [ -z "${SELECTED_WINDOW}" ]; then
#                 local geometry=$(grab_window)
#             else
#                 local geometry=$(grab_selected_window "${SELECTED_WINDOW}")
#             fi
#                 geometry=$(trim "${geometry}")
#             ;;
        *)
            geometry="$SELECTION"
            ;;
    esac
    echo "$geometry"
}

function grab_region() {
    slurp -d -w "$SLURP_BORDER_WEIGHT"
}

function grab_monitor() {
    slurp -or
}

function grab_monitor_active() {
    local active_workspace_id=$(hyprctl -j activeworkspace | jq -r '.id')
    local monitors=$(hyprctl -j monitors)
    local active_monitor="$(echo $monitors \
        | jq -r '.[] | select(.activeWorkspace.id == '$active_workspace_id')')"

    Print -2 "Active workspace ID: $active_workspace_id\n"
    Print -2 "Monitors: $monitors\n"
    Print -2 "Current monitor: $active_monitor\n"

    echo $active_monitor \
        | jq -r '"\(.x),\(.y) \(.width/.scale|round)x\(.height/.scale|round)"'
}

function grab_monitor_match() {
    local name="$1"
    local monitors=$(hyprctl -j monitors)
    local matching_monitor=$(echo $monitors \
        | jq --arg name "$name" -r '.[] | select(.name == $name)')

    Print -2 "Monitors: $monitors\n"
    Print -2 "Matching monitor: $matching_monitor\n"

    if [ -z "$matching_monitor" ]; then
        Print -E "Error: No monitor with name '$name' found.\n"
        exit 1
    fi

    echo $matching_monitor \
        | jq -r '"\(.x),\(.y) \(.width/.scale|round)x\(.height/.scale|round)"'
}

# function grab_window() {
#     local monitors=$(hyprctl -j monitors)
#     local clients=$(hyprctl -j clients | jq -r '[.[] | select(.workspace.id | contains('$(echo $monitors | jq -r 'map(.activeWorkspace.id) | join(",")')'))]')
#     Print "Monitors: %s\n" "$monitors"
#     Print "Clients: %s\n" "$clients"
#     # Generate boxes for each visible window and send that to slurp
#     # through stdin
#     local boxes="$(echo $clients | jq -r '.[] | "\(.at[0]),\(.at[1]) \(.size[0])x\(.size[1]) \(.title)"' | cut -f1,2 -d' ')"
#     Print "Boxes:\n%s\n" "$boxes"
#     slurp -r <<< "$boxes"
# }

# function grab_selected_window() {
#     local window=$(hyprctl -j clients | jq --arg title "$1" -r '.[] | select(.title == $title)')
#     Print "Capturing: %s\n" "${1}"
#     echo $window | jq -r '"\(.at[0]),\(.at[1]) \(.size[0])x\(.size[1])"'
# }

# function grab_active_window() {
#     local active_window=$(hyprctl -j activewindow)
#     local box=$(echo $active_window | jq -r '"\(.at[0]),\(.at[1]) \(.size[0])x\(.size[1])"' | cut -f1,2 -d' ')
#     Print "Box:\n%s\n" "$box"
#     echo "$box"
# }

# --------------- Trimming ---------------

function trim_slurp_border() {
    local geometry="$1"
    local border=$SLURP_BORDER_WEIGHT

    local xy_str=${geometry% *} # Get the first part (X,Y)
    local wh_str=${geometry#* } # Get the second part (WxH)
    local x=${xy_str%,*}        # Get the X coordinate
    local y=${xy_str#*,}        # Get the Y coordinate
    local width=${wh_str%x*}    # Get the width
    local height=${wh_str#*x}   # Get the height

    # Remove the 1px border
    x=$((x + $border))
    y=$((y + $border))
    width=$((width - 2 * $border))
    height=$((height - 2 * $border))

    # Ensure width and height are not negative
    [ $width -lt 0 ] && width=0
    [ $height -lt 0 ] && height=0

    # Output the trimmed geometry
    echo "$x,$y ${width}x${height}"
}

# function trim() {
#     Print "Geometry: %s\n" "${1}"
#     local geometry="${1}"
#     local xy_str=$(echo "${geometry}" | cut -d' ' -f1)
#     local wh_str=$(echo "${geometry}" | cut -d' ' -f2)
#     local x=$(echo "${xy_str}" | cut -d',' -f1)
#     local y=$(echo "${xy_str}" | cut -d',' -f2)
#     local width=$(echo "${wh_str}" | cut -dx -f1)
#     local height=$(echo "${wh_str}" | cut -dx -f2)

#     local max_width=$(hyprctl monitors -j | jq -r '[.[] | if (.transform % 2 == 0) then (.x + .width) else (.x + .height) end] | max')
#     local max_height=$(hyprctl monitors -j | jq -r '[.[] | if (.transform % 2 == 0) then (.y + .height) else (.y + .width) end] | max')

#     local min_x=$(hyprctl monitors -j | jq -r '[.[] | (.x)] | min')
#     local min_y=$(hyprctl monitors -j | jq -r '[.[] | (.y)] | min')

#     local cropped_x=$x
#     local cropped_y=$y
#     local cropped_width=$width
#     local cropped_height=$height

#     if ((x + width > max_width)); then
#         cropped_width=$((max_width - x))
#     fi
#     if ((y + height > max_height)); then
#         cropped_height=$((max_height - y))
#     fi

#     if ((x < min_x)); then
#         cropped_x="$min_x"
#         cropped_width=$((cropped_width + x - min_x))
#     fi
#     if ((y < min_y)); then
#         cropped_y="$min_y"
#         cropped_height=$((cropped_height + y - min_y))
#     fi

#     local cropped=$(printf "%s,%s %sx%s\n" \
#         "${cropped_x}" "${cropped_y}" \
#         "${cropped_width}" "${cropped_height}")
#     Print "Crop: %s\n" "${cropped}"
#     echo ${cropped}
# }

# =============== Secondary operations ===============

# --------------- Notifications --------------

# TODO: Finish implementing this
# readonly ACTIONS_ARGS=("-")

# function notify() {
#     [ $NOTIFY -eq 0 ] && return 0

#     local message=""
#     [ $CLIPBOARD -eq 1 ] && message+=$'Copied to the clipboard.\n'
#     [ $SAVE -eq 1 ] && message+="Saved in <i>$SAVE_FULLPATH</i>."

#     if [ $ACTIONS -eq 1 ]; then
#         action=$(notify-send "Screenshot captured" \
#             "${message}" \
#             -t "$NOTIF_TIMEOUT" -i "$CAPTURE_FULLPATH" -a Hyprcap \
#             -h string:x-dunst-stack-tag:$DUNST_TAG \
#             -A default="Save to file" \
#             -A copy="Copy to clipboard" \
#             -A edit="Edit" \
#             2>/dev/null)
#         [ "$action" = "default" ] && action="save"
#         # If actions is invalid or none, act_on_capture fails and this stops
#         act_on_capture "$action" && notify
#     else
#         notify-send "Screenshot captured" \
#             "${message}" \
#             -t "$NOTIF_TIMEOUT" -i "${1}" -a Hyprcap \
#             -h string:x-dunst-stack-tag:$DUNST_TAG
#     fi
# }

# --------------- Post-capture actions ---------------

# function act_on_capture() {
#     local acted=0
#     case "$1" in
#         save)
#             # TODO: implement choosing through an xdg-desktop-portal file dialog
#             save_capture >/dev/null
#             acted=1
#             ;;
#         copy)
#             copy_capture >/dev/null
#             acted=1
#             ;;
#         edit)
#             edit_capture >/dev/null
#             acted=1
#             ;;
#     esac
#     # Return 0 if acted, 1 if action was invalid or none
#     [[ $acted -ne 0 ]] && return 0 || return 1
# }

# function save_capture() {
#     SAVE=1
#     mkdir -p "$SAVEDIR"
#     cat "$CAPTURE_FULLPATH" > "$SAVE_FULLPATH"
#     Print "Saving in: %s\n" "$SAVE_FULLPATH"
#     echo "$SAVE_FULLPATH"
# }

# function copy_capture() {
#     CLIPBOARD=1
#     wl-copy --type image/png < "$CAPTURE_FULLPATH"
#     echo "$CAPTURE_FULLPATH"
# }

# function edit_capture() {
#     swappy -f "$CAPTURE_FULLPATH" -o "$SAVE_FULLPATH"
# }

# --------------- Freezing ---------------

# TODO: Improve this or something
# function checkRunning() {
#     sleep 1
#     while [[ 1 == 1 ]]; do
#         if [[ $(pgrep slurp | wc -m) == 0 ]]; then
#             pkill hyprpicker
#             exit
#         fi
#     done
# }

# TODO: Ensure this implementation works.
# function freeze() {
#     if [ $FREEZE -eq 1 ] && [ "$(command -v "hyprpicker")" ] >/dev/null 2>&1; then
#         hyprpicker -r -z &
#         sleep 0.2
#         # HYPRPICKER_PID=$!
#     fi
# }

# =============== Argument parsing ===============

function args() {
    local OPTS="s:o:f:Fcd:znNaAt:rVqvh"
    local LONG_OPTS="select:,output-dir:,filename:,no-file,copy,delay:,freeze,"
    LONG_OPTS+="notify,no-notify,actions,no-actions,notif-timeout:"
    LONG_OPTS+="raw,verbose,quiet,version,help"

    local options=$(getopt -o $OPTS --long $LONG_OPTS -- "$@")
    eval set -- "$options"

    while true; do
        case "$1" in
            -s | --select)
                local selection="$2" # Parsing is done later
                shift;;

            -o | --output-dir)
                SAVE=1
                OUTPUT_DIR="$2"
                NYI && exit 1 # TODO: Remove when implemented
                shift;;
            -f | --filename)
                SAVE=1
                FILENAME="$2"
                NYI && exit 1 # TODO: Remove when implemented
                shift;;
            -F | --no-file)
                SAVE=0
                ;;
            -c | --copy)
                COPY=1
                NYI && exit 1 # TODO: Remove when implemented
                ;;

            -d | --delay)
                DELAY="$2"
                NYI && exit 1 # TODO: Remove when implemented
                shift;;
            -z | --freeze)
                FREEZE=1
                NYI && exit 1 # TODO: Remove when implemented
                ;;

            -n | --notify)
                NOTIFY=1
                NYI && exit 1 # TODO: Remove when implemented
                ;;
            -N | --no-notify)
                NOTIFY=0
                ;;
            -a | --actions)
                ACTIONS=1
                NYI && exit 1 # TODO: Remove when implemented
                ;;
            -A | --no-actions)
                ACTIONS=0
                ;;
            -t | --notif-timeout)
                NOTIF_TIMEOUT=$2
                NYI && exit 1 # TODO: Remove when implemented
                shift;;

            -r | --raw)
                RAW=1
                NYI && exit 1 # TODO: Remove when implemented
                ;;
            -v | --verbose)
                VERBOSE+=1
                ;;
            -q | --quiet)
                VERBOSE=-1
                ;;
            -V | --version)
                Version
                exit 0;;
            -h | --help)
                Help
                exit 0;;

            --) # Marks the end of options
                shift && break;;
        esac
        shift
    done
    shift # Remove the command itself from the arguments

    # -- Command --
    # Check if a command was specified
    if [ -z "$1" ]; then
        Print -E "Fatal: No command specified. Use --help for help.\n"
        exit 1
    fi
    COMMAND=$(parse_command "$1")

    # -- Selection --
    # If a selection was not specified already and there is another argument,
    # use it as the selection
    [ -z "$selection" -a -n "$2" ] && selection="$2"

    # If no selection is done yet, fail
    # TODO: Remove this when dmenu-based selection is implemented
    if [ -z "$selection" ]; then
        Print -E "Fatal: No selection specified. Use --help for help.\n"
        exit 1
    fi

    parse_selection "$selection" # Errors and exit if selection is invalid
}

function parse_command() {
    case "$1" in
        shot | screenshot)
            echo "screenshot"
            ;;
        rec | record)
            echo "record"
            ;;
        *)
            Print -E "Fatal: Unknown command '$1'\n"
            exit 1
            ;;
    esac
}

function parse_selection() {
    local selection=

    case "$1" in
        region:*) # Region may specify the geometry directly
            selection="${1#region:}"
            ;;
        *:active)
            SELECT_ACTIVE=1
            selection="${1%:active}"
            ;;
        *:* | *:*)
            SELECT_MATCH="${1#*:}"
            selection="${1%%:$SELECT_MATCH}"
            ;;
        *)
            selection="$1"
            ;;
    esac

    case "$selection" in
        window | region | monitor)
            SELECTION="$selection"
            ;;
        *,*,*x*) # Geometry in the form X,Y,WxH: translate to X,Y WxH
            SELECTION="${selection%,*} ${selection#*,*,}"
            ;;
        *)
            Print -E "Fatal: Unknown selection '$1'\n"
            exit 1;;
    esac
}

# function prompt_options() {
#     visible_windows=$(list_geometry)

#     dmenu_text=$'Region\nActive monitor\nMonitor\nActive window\nWindow\n'
#     dmenu_text+=$(echo $visible_windows | jq -r '"Window:\t\(.title)"')

#     option_name=$(echo "$dmenu_text" | $DMENU_COMMAND)

#     case "$option_name" in
#         Active*) # Current monitor or window
#             CURRENT=1
#             ;;&
#         *[Mm]onitor)
#             OPTION=output
#             ;;
#         *[Ww]indow)
#             OPTION=window
#             ;;
#         Region)
#             OPTION=region
#             ;;
#         *)
#             parse_mode "$option_name"
#             ;;
#     esac
#     sleep 0.1; # Because sometimes it takes just a moment to fade out
# }

# =============== Main flow ===============

# ---- Pre-init ----

# ---- Options and defaults ----

# Selection
SELECTION=
SELECT_ACTIVE=0
SELECT_MATCH=

# Saving
# SAVE=0 # not implemented yet
# OUTPUT_DIR= # not implemented yet
# [ -z "$XDG_PICTURES_DIR" ] && type xdg-user-dir >/dev/null && XDG_PICTURES_DIR=$(xdg-user-dir PICTURES)
# FILENAME="$(date +'%Y-%m-%d-%H%M%S_hyprcap.png')"
# [ -z "$HYPRCAP_DIR" ] && SAVEDIR=${XDG_PICTURES_DIR:=~/Pictures} || SAVEDIR=${HYPRCAP_DIR}
# COPY=0 # not implemented yet

# Behavior
# FREEZE=0 # not implemented yet

# # Notifications # not implemented yet
# NOTIFY=0
# ACTIONS=1
# NOTIF_TIMEOUT=10000

# Output
VERBOSE=0
# RAW=0 # not implemented yet

args $0 "$@"

Print -1 "Running HyprCap version $VERSION\n"
Print -1 "Command selected: $COMMAND\n"

# TODO: Call freeze around here

# [ -z $OPTION ] && prompt_options

Print -1 "Selection: $SELECTION"
Print -1 " (active: ${SELECT_ACTIVE:-no}, match: '$SELECT_MATCH')\n"

GEOMETRY=$(get_geometry)

case "$GEOMETRY" in
    *[0-9]*,*[0-9]*' '[0-9]*x[0-9]*) # Valid geometry
        ;;
    *)
        Print -E "Fatal: Resolved geometry '$GEOMETRY' is invalid.\n"
        exit 1;;
esac

Print -1 "Geometry: $GEOMETRY\n"

# if [ $DELAY -gt 0 ] 2>/dev/null; then
#     sleep $DELAY
# fi
# capture "$geometry"

# if [ -z "$XDG_PICTURES_DIR" ]; then
#    type xdg-user-dir >/dev/null && XDG_PICTURES_DIR=$(xdg-user-dir PICTURES)
# fi

# SAVE_PATH="$OUTPUT_DIR/$CAPTURE_FILENAME"
# [ $SAVE -eq 1 ] && Print "Saving in: %s\n" "$SAVE_FULLPATH"
# begin_grab $OPTION & checkRunning
